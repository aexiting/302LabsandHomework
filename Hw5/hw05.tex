\documentclass[letterpaper,11pt]{article}

\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newtheorem{theorem}{Theorem}[section]

\begin{document}
\noindent{COSC 302: Analysis of Algorithms --- Spring 2018}

\noindent{Prof. Darren Strash}

\noindent{Colgate University} \\

\noindent{\bf Problem Set 5 --- Heaps, Non-comparison sorts, Red-black trees, Hashing} \\

\emph{Suggested practice problems, from CLRS:} Ch 11.1 (1 and 2); 11.2-3; 12.2 (3, 4, and 5); 12.3-5; 13.3 (1, 2, and 4) 

\begin{enumerate}

\item In this problem, we will investigate $d$-ary max-heaps: A $d$-ary heap is one in which each node has at most $d$ children, whereas, in a binary heap, each node has at most $2$ children.

\begin{enumerate}
\item 
We can represent a d-heap in an array which the second element is the root. Then for any parent node $x$ it's children are located $(x*d)+1,(x*d)+2,...(x*d)+d$. An for any child can find it's parent by  $(x-1)/d$.

\item 
Assuming the root is at level $0$. Then if the $d$-ary heap is completely filled then the $i$th level will be $d^i$. So the to find the nodes up to the last level of the heap at level $l$ would be: \\ 
\begin{equation}
\sum_{i=0}^{l} d^i = \frac{d^{l+1}-1}{d-1} 
\end{equation}
This function describes the amount of nodes, or $n$, so we need to solve for $l$ which would be the height.
\begin{equation}
 \begin{aligned}
    n = \frac{d^{l+1}-1}{d-1} \\
    n(d-1) = d^{l+1}-1 \\
   log_d (n(d-1)+1)-1 = l           
  \end{aligned} 
\end{equation}
This height is $\Theta(log_d (n(d-1)+1)-1)$.
\item Re-write function \textsc{Parent}($i$) for $d$-ary heaps, and give a new function \textsc{Child}($i$,$j$) that gives the $j$-th child of node $i$ (where $1\leq j \leq d$).
\begin{algorithm}
\begin{algorithmic}[1]
\Function{Parent}{$i$}
\State \Return $(i-1)/d$
\EndFunction
\Function{Child}{$x,j$}
\State \Return $(i*d)+j$
\EndFunction
\end{algorithmic}
\end{algorithm}
\item Describe, and give pseudocode for, the algorithm \textsc{Max-Heapify}($A$,$i$) for $d$-ary heaps and give a tight analysis for the worst-case running time of your algorithm.


\item Describe (semi-formally) how to implement \textsc{Max-Heapify}($A$,$i$) in $O((\log_dn)\lg d)$ time. \emph{(Hint: you need auxiliary data structures; the heap itself is not sufficient.)}
\end{enumerate}

\item \textbf{(From homework 4, skip if already submitted)} Problem 8.2-4 from CLRS: Describe (semi-formally) an algorithm that, given $n$ integers in the range $0$ to $k$, preprocesses its input and then answers any query about how many of the $n$ integers fall into a range $[a..b]$ in $O(1)$ time. Your algorithm should use $\Theta(n + k)$ preprocessing time.

\item Problem 13.3-5 from CLRS. (Describe semi-formally.) \emph{(Hint: Follow the structure for an invariant.)}

\item \textbf{(Previous exam question)} Let $A[1..n]$ be an array of non-integers taken from some set $K$ of size $k>1$. \emph{(Note: For this problem, you are not given the set $K$ or $k$; this is only to illustrate that there are $k$ distinct non-integer numbers. We only have access to elements through $A$. Further, note that $k$ may be small or large: from constant to even larger than $n$.)}
\begin{enumerate}
\item Describe an algorithm that sorts $A$ in expected time $O(n + k\lg k)$, and describe why it has this running time. 

\item What is the worst-case running time of your algorithm? Justify your answer.
\end{enumerate}

\end{enumerate}

\end{document}
